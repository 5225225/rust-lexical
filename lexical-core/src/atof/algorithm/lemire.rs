//! Fast estimation of the accurate representation of a float.
//!
//! This is currently a working prototype, and aims to replace
//! `moderate_path` in `correct`.
//!
//! Based off the Golang implementation of the Eisel-Lemire algorithm,
//! found here:
//!     https://github.com/golang/go/blob/2ebe77a2fda1ee9ff6fd9a3e08933ad1ebaea039/src/strconv/eisel_lemire.go
//!
//! More specifically, we base it off the Wuff's implementation:
//!     https://github.com/google/wuffs/blob/ba3818cb6b473a2ed0b38ecfc07dbbd3a97e8ae7/internal/cgen/base/floatconv-submodule-code.c
//!
//! The original algorithm may be found here:
//!     https://github.com/lemire/fast_double_parser
//!
//! And an in-depth blogpost describing the algorithms may be found here:
//!     https://nigeltao.github.io/blog/2020/eisel-lemire.html

#![allow(unused)] // TODO(ahuszagh) Remove

use crate::float::*;
use crate::traits::*;
use crate::util::*;

use super::alias::*;
use super::cached::ModeratePathCache;

/// Create a precise native float using an intermediate extended-precision float.
///
/// Return the float approximation and if the value can be accurately
/// represented with mantissa bits of precision.
#[inline(always)]
pub(super) fn moderate_path<F, M>(
    mantissa: M,
    radix: u32,
    exponent: i32,
    truncated: bool,
    is_lossy: bool,
    kind: RoundingKind,
) -> (F, bool)
where
    M: MantissaType,
    F: Float,
    ExtendedFloat<M>: ModeratePathCache<M>,
{
    // TODO(ahuszagh) Here...
    let powers = ExtendedFloat::<M>::get_powers(radix);

    let ctlz = mantissa.leading_zeros();
    let mantissa = mantissa << ctlz;
    let bias = -(F::EXPONENT_BIAS - F::MANTISSA_SIZE); // 1023 for f64
    let shift = 16 + M::FULL + bias;
    // Guessing this is a hard-coded constant to convert
    //let exp2 = 217706 * exponent
    // Ummm wtf
    // What are these hard-coded constants
    //  0x3526a

    // Check how many bits we need for 128:
    //      14267572527 is for 32
    //          We should check for every power of 10
    // We should use 32-bits for
    //- 217706 is such that the ratio 217706 / 65536 ≈ 3.321930 is close enough
    //  //    (over the practical range of exp10) to log(10) / log(2) ≈ 3.321928.
    //  //  - 65536 = 1<<16 is arbitrary but a power of 2, so division is a shift.

    //    NorMan = (Man << CLZ(Man)) = (0x7B << 57) = 0xF6000000_00000000
    //    AdjE2_0 = (NarrowBiasedE2 - CLZ(Man)) = ((1150 + 79) - 57) = 1172

    // Is this the real exponent, or the mantissa exponent?
    //  I believe it's the mantissa exponent.
    // Lmao what is this fucking bitshift? Dafuqqqqqqq
    //      So this equal to (217706*exp10 as u64) >> 54
    //      How do we get 54? If we have (217706*exp10 as u64) >> 1103,
    //      there's no normal way to get 54...
    //          (217706 * exp10 >> 16) + 64 + 1023
    //          So 217706 is a magic number for log2(10) << 16
    //retExp2 := uint64(217706*exp10>>16+64+float64ExponentBias) - uint64(clz)

    todo!()
    //    let mut fp = ExtendedFloat {
    //        mant: mantissa,
    //        exp: 0,
    //    };
    //    let valid = multiply_exponent_extended::<F, M>(&mut fp, radix, exponent, truncated, kind);
    //    (fp, valid)
}

// TODO(ahuszagh) Going to need to use small/large powers
//      I'm not hard-coding an array for 360+ powers-of-2
//      I already have cached large_powers

// The powers-of-10 look-up table is generated by this Go program.
// The two u64 columns are explicitly printed, and the one i32 column
// is implied by a linear expression with slope log(10)/log(2).

// TEST
// ----

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_halfway_round_down() {
        // TODO(ahuszagh) Implement...
        let radix = 10;
        let kind = RoundingKind::NearestTieEven;

        //        // Halfway, round-down tests
        //        assert!(moderate_path::<f64, _>(9007199254740992u64, radix, 0, false, kind).1);
        //        assert!(!moderate_path::<f64, _>(9007199254740993u64, radix, 0, false, kind).1);
        //        assert!(moderate_path::<f64, _>(9007199254740994u64, radix, 0, false, kind).1);
        //
        //        assert!(moderate_path::<f64, _>(18014398509481984u64, radix, 0, false, kind).1);
        //        assert!(!moderate_path::<f64, _>(18014398509481986u64, radix, 0, false, kind).1);
        //        assert!(moderate_path::<f64, _>(18014398509481988u64, radix, 0, false, kind).1);
        //
        //        assert!(moderate_path::<f64, _>(9223372036854775808u64, radix, 0, false, kind).1);
        //        assert!(!moderate_path::<f64, _>(9223372036854776832u64, radix, 0, false, kind).1);
        //        assert!(moderate_path::<f64, _>(9223372036854777856u64, radix, 0, false, kind).1);
        //
        //        // Add a 0 but say we're truncated.
        //        assert!(moderate_path::<f64, _>(9007199254740992000u64, radix, -3, true, kind).1);
        //        assert!(!moderate_path::<f64, _>(9007199254740993000u64, radix, -3, true, kind).1);
        //        assert!(moderate_path::<f64, _>(9007199254740994000u64, radix, -3, true, kind).1);
    }

    //    #[test]
    //    fn test_halfway_round_up() {
    //        let radix = 10;
    //        let kind = RoundingKind::NearestTieEven;
    //
    //        // Halfway, round-down tests
    //        assert!(moderate_path::<f64, _>(9007199254740994u64, radix, 0, false, kind).1);
    //        assert!(!moderate_path::<f64, _>(9007199254740995u64, radix, 0, false, kind).1);
    //        assert!(moderate_path::<f64, _>(9007199254740996u64, radix, 0, false, kind).1);
    //
    //        assert!(moderate_path::<f64, _>(18014398509481988u64, radix, 0, false, kind).1);
    //        assert!(!moderate_path::<f64, _>(18014398509481990u64, radix, 0, false, kind).1);
    //        assert!(moderate_path::<f64, _>(18014398509481992u64, radix, 0, false, kind).1);
    //
    //        assert!(moderate_path::<f64, _>(9223372036854777856u64, radix, 0, false, kind).1);
    //        assert!(!moderate_path::<f64, _>(9223372036854778880u64, radix, 0, false, kind).1);
    //        assert!(moderate_path::<f64, _>(9223372036854779904u64, radix, 0, false, kind).1);
    //
    //        // Add a 0 but say we're truncated.
    //        assert!(moderate_path::<f64, _>(9007199254740994000u64, radix, -3, true, kind).1);
    //        assert!(!moderate_path::<f64, _>(9007199254740994990u64, radix, -3, true, kind).1);
    //        assert!(!moderate_path::<f64, _>(9007199254740995000u64, radix, -3, true, kind).1);
    //        assert!(!moderate_path::<f64, _>(9007199254740995010u64, radix, -3, true, kind).1);
    //        assert!(moderate_path::<f64, _>(9007199254740996000u64, radix, -3, true, kind).1);
    //    }
    //
    //    #[test]
    //    #[cfg(feature = "radix")]
    //    fn float_moderate_path_test() {
    //        // valid (overflowing small mult)
    //        let mantissa: u64 = 1 << 63;
    //        let (f, valid) =
    //            moderate_path::<f32, _>(mantissa, 3, 1, false, RoundingKind::NearestTieEven);
    //        assert_eq!(f.into_f32(), 2.7670116e+19);
    //        assert!(valid, "exponent should be valid");
    //
    //        let mantissa: u64 = 4746067219335938;
    //        let (f, valid) =
    //            moderate_path::<f32, _>(mantissa, 15, -9, false, RoundingKind::NearestTieEven);
    //        assert_eq!(f.into_f32(), 123456.1);
    //        assert!(valid, "exponent should be valid");
    //    }
    //
    //    #[test]
    //    #[cfg(feature = "radix")]
    //    fn double_moderate_path_test() {
    //        // valid (overflowing small mult)
    //        let mantissa: u64 = 1 << 63;
    //        let (f, valid) =
    //            moderate_path::<f64, _>(mantissa, 3, 1, false, RoundingKind::NearestTieEven);
    //        assert_eq!(f.into_f64(), 2.7670116110564327e+19);
    //        assert!(valid, "exponent should be valid");
    //
    //        // valid (ends of the earth, salting the earth)
    //        let (f, valid) =
    //            moderate_path::<f64, _>(mantissa, 3, -695, true, RoundingKind::NearestTieEven);
    //        assert_eq!(f.into_f64(), 2.32069302345e-313);
    //        assert!(valid, "exponent should be valid");
    //
    //        // invalid ("268A6.177777778", base 15)
    //        let mantissa: u64 = 4746067219335938;
    //        let (_, valid) =
    //            moderate_path::<f64, _>(mantissa, 15, -9, false, RoundingKind::NearestTieEven);
    //        assert!(!valid, "exponent should be invalid");
    //
    //        // valid ("268A6.177777778", base 15)
    //        // 123456.10000000001300614743687445, exactly, should not round up.
    //        #[cfg(feature = "f128")]
    //        {
    //            let mantissa: u128 = 4746067219335938;
    //            let (f, valid) =
    //                moderate_path::<f64, _>(mantissa, 15, -9, false, RoundingKind::NearestTieEven);
    //            assert_eq!(f.into_f64(), 123456.1);
    //            assert!(valid, "exponent should be valid");
    //        }
    //
    //        // Rounding error
    //        // Adapted from test-parse-random failures.
    //        let mantissa: u64 = 1009;
    //        let (_, valid) =
    //            moderate_path::<f64, _>(mantissa, 10, -31, false, RoundingKind::NearestTieEven);
    //        assert!(!valid, "exponent should be valid");
    //    }
}
